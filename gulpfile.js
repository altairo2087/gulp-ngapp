// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var DIST_PATH, ENV_CURRENT, ENV_DEV, ENV_PROD, IMAGES, ORDER_VENDOR_CSS, ORDER_VENDOR_JS, PORT, PUBLIC_PATH, Q, bower, build, clean, coffee, css, filter, gulp, html, images, inject, jade, js, log, opts, orderedCustomJs, orderedVendorCss, orderedVendorJs, plugins, ref, sass, server, task, tasks;

  gulp = require('gulp');

  Q = require('q');

  plugins = (require('gulp-load-plugins'))({
    pattern: ['gulp-*', 'gulp.*', 'del', 'main-bower-files'],
    replaceString: /\bgulp[\-.]/
  });

  PORT = 8000;

  DIST_PATH = 'dist';

  PUBLIC_PATH = 'public';

  IMAGES = ['png', 'jpg', 'jpeg', 'gif', 'ico', 'bmp'];

  ORDER_VENDOR_CSS = ["*bootstrap.*", "*bootstrap*"];

  ORDER_VENDOR_JS = ["*jquery*", "*bootstrap.*", "*bootstrap*", "!*angular*", "*angular.*", "*angular*"];

  ENV_PROD = 'prod';

  ENV_DEV = 'dev';

  if (plugins.util.env.env) {
    if ((ref = !plugins.util.env.env) === ENV_PROD || ref === ENV_DEV) {
      throw new Error('unknown env');
    }
    ENV_CURRENT = plugins.util.env.env;
  } else {
    ENV_CURRENT = ENV_DEV;
  }

  log = function(error) {
    console.log((new Date.toString) + ":Error " + error.name + " in " + error.plugin + "\n " + error.message + "\n");
    return this.end();
  };

  clean = function() {
    return plugins.del([PUBLIC_PATH + "/**", "!" + PUBLIC_PATH, "!" + PUBLIC_PATH + "/.gitkeep"]);
  };

  orderedVendorJs = function() {
    return gulp.src(PUBLIC_PATH + "/vendor/*.js", {
      read: false
    }).pipe(plugins.order(ORDER_VENDOR_JS));
  };

  orderedCustomJs = function() {
    return gulp.src([PUBLIC_PATH + "/**/*.js", "!" + PUBLIC_PATH + "/vendor/**/*"], {
      read: false
    }).pipe(plugins.order([]));
  };

  orderedVendorCss = function() {
    return gulp.src(PUBLIC_PATH + "/**/*.css", {
      read: false
    }).pipe(plugins.order(ORDER_VENDOR_CSS));
  };

  server = function() {
    return gulp.src(PUBLIC_PATH).pipe(plugins.webserver({
      livereload: true,
      open: true,
      port: PORT
    }));
  };

  jade = function() {
    return gulp.src(DIST_PATH + "/**/*.jade").pipe(plugins.jade()).pipe(plugins.prettify({
      indent_size: 2
    })).pipe(gulp.dest(PUBLIC_PATH));
  };

  html = function() {
    return gulp.src(DIST_PATH + "/**/*.html").pipe(plugins.prettify({
      indent_size: 2
    })).pipe(gulp.dest(PUBLIC_PATH));
  };

  images = function() {
    var ext;
    images = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = IMAGES.length; i < len; i++) {
        ext = IMAGES[i];
        results.push(DIST_PATH + "/**/*." + ext);
      }
      return results;
    })();
    return gulp.src(images).pipe(gulp.dest(PUBLIC_PATH));
  };

  sass = function() {
    return gulp.src([DIST_PATH + "/**/*.sass", DIST_PATH + "/**/*.scss"]).pipe(plugins.sass()).pipe(gulp.dest(PUBLIC_PATH));
  };

  css = function() {
    return gulp.src(DIST_PATH + "/**/*.css").pipe(plugins.autoprefixer()).pipe(gulp.dest(PUBLIC_PATH));
  };

  filter = function(types) {
    return plugins.filter(types, {
      restore: true
    });
  };

  coffee = function() {
    return gulp.src(DIST_PATH + "/**/*.coffee").pipe(plugins.coffee()).pipe(gulp.dest(PUBLIC_PATH));
  };

  js = function() {
    return gulp.src(DIST_PATH + "/**/*.js").pipe(gulp.dest(PUBLIC_PATH));
  };

  inject = function() {
    var q;
    q = Q.defer();
    gulp.src(PUBLIC_PATH + "/**/*.inject.html").pipe(plugins.inject(orderedVendorCss(), {
      name: 'bower',
      relative: true
    })).pipe(plugins.inject(orderedVendorJs(), {
      name: 'bower',
      relative: true
    })).pipe(plugins.inject(orderedCustomJs(), {
      relative: true
    })).pipe(plugins.rename(function(path) {
      return path.basename = path.basename.replace('.inject', '');
    })).pipe(gulp.dest(PUBLIC_PATH)).on('end', function() {
      return plugins.del(PUBLIC_PATH + "/**/*.inject.html").then(function() {
        if (ENV_CURRENT === ENV_PROD) {
          gulp.src(PUBLIC_PATH + "/**/*.html").pipe(plugins.angularHtmlify()).pipe(plugins.htmlmin({
            collapseWhitespace: true,
            removeComments: true
          })).pipe(gulp.dest(PUBLIC_PATH));
        }
        return q.resolve();
      });
    });
    return q.promise;
  };

  bower = function() {
    var cssFilter, jsFilter, q, src;
    q = Q.defer();
    cssFilter = filter('**/*.css');
    jsFilter = filter('**/*.js');
    src = gulp.src(plugins.mainBowerFiles({
      overrides: {
        bootstrap: {
          main: ["./dist/js/bootstrap.js", "./dist/css/bootstrap.css", "./dist/fonts/*"]
        }
      }
    }));
    if (ENV_CURRENT === ENV_PROD) {
      src = src.pipe(cssFilter).pipe(plugins.cssUrlAdjuster({
        replace: ['../fonts', './']
      })).pipe(plugins.order(ORDER_VENDOR_CSS)).pipe(plugins.concat('vendor.css')).pipe(plugins.csso()).pipe(cssFilter.restore);
    } else {
      src = src.pipe(cssFilter).pipe(plugins.cssUrlAdjuster({
        replace: ['../fonts', './']
      })).pipe(cssFilter.restore);
    }
    if (ENV_CURRENT === ENV_PROD) {
      src = src.pipe(jsFilter).pipe(plugins.order(ORDER_VENDOR_JS)).pipe(plugins.concat('vendor.js')).pipe(plugins.uglify({
        mangle: true
      })).pipe(jsFilter.restore);
    }
    src.pipe(gulp.dest(PUBLIC_PATH + "/vendor")).on('end', function() {
      return q.resolve();
    });
    return q.promise;
  };

  build = function() {
    return clean().then(function() {
      return Q.all(jade()).then(function() {
        return bower().then(function() {
          return inject();
        });
      });
    });
  };

  tasks = {
    clean: {
      desc: "clean " + PUBLIC_PATH + " folder",
      action: clean
    },
    server: {
      desc: "start local server on port " + PORT,
      action: server
    },
    build: {
      desc: "build app: '--env [prod|dev]' default 'dev'",
      action: build
    },
    "default": {
      action: function() {
        var opts, results, task;
        results = [];
        for (task in tasks) {
          opts = tasks[task];
          results.push(console.log(task + " - " + opts.desc));
        }
        return results;
      }
    }
  };

  for (task in tasks) {
    opts = tasks[task];
    gulp.task(task, opts.action);
  }

}).call(this);

//# sourceMappingURL=gulpfile.js.map
