// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var DIST_PATH, ENV, ENV_CURRENT, Html, IMAGES, Inject, OPEN_BROWSER, ORDER_VENDOR_CSS, ORDER_VENDOR_JS, PORT, PUBLIC_PATH, Q, SERVER_WATCH, bower, browserSync, build, clean, coffee, css, filter, gulp, html, images, jadeWatch, js, opts, plugins, ref, sass, server, task, tasks, watch,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  gulp = require('gulp');

  Q = require('q');

  plugins = (require('gulp-load-plugins'))({
    pattern: ['gulp-*', 'gulp.*', 'del', 'main-bower-files'],
    replaceString: /\bgulp[\-.]/
  });

  browserSync = require('browser-sync').create();

  PORT = 3000;

  OPEN_BROWSER = false;

  SERVER_WATCH = true;

  DIST_PATH = 'dist';

  PUBLIC_PATH = 'public';

  IMAGES = ['png', 'jpg', 'jpeg', 'gif', 'ico', 'bmp', 'webp'];

  ORDER_VENDOR_CSS = ["*bootstrap.*", "*bootstrap*"];

  ORDER_VENDOR_JS = ["*jquery*", "*bootstrap.*", "*bootstrap*", "!*angular*", "*angular.*", "*angular*"];

  ENV = [
    {
      PROD: 'prod',
      DEV: 'dev'
    }
  ];

  ENV_CURRENT = ENV.DEV;

  if (plugins.util.env.env) {
    if (ref = !plugins.util.env.env, indexOf.call(ENV, ref) >= 0) {
      throw new Error('unknown env');
    }
    ENV_CURRENT = plugins.util.env.env;
  }

  if (plugins.util.env.watch !== void 0) {
    SERVER_WATCH = plugins.util.env.watch !== "false";
  }

  clean = function() {
    return plugins.del([PUBLIC_PATH + "/**", "!" + PUBLIC_PATH, "!" + PUBLIC_PATH + "/.gitkeep"]);
  };

  filter = function(types) {
    return plugins.filter(types, {
      restore: true
    });
  };

  Inject = {
    orderedVendorJs: function() {
      return gulp.src(PUBLIC_PATH + "/vendor/*.js", {
        read: false
      }).pipe(plugins.order(ORDER_VENDOR_JS));
    },
    orderedCustomJs: function() {
      return gulp.src([PUBLIC_PATH + "/**/*.js", "!" + PUBLIC_PATH + "/vendor/**/*"], {
        read: false
      }).pipe(plugins.order([]));
    },
    orderedVendorCss: function() {
      return gulp.src(PUBLIC_PATH + "/vendor/*.css", {
        read: false
      }).pipe(plugins.order(ORDER_VENDOR_CSS));
    },
    orderedCustomCss: function() {
      return gulp.src([PUBLIC_PATH + "/**/*.css", "!" + PUBLIC_PATH + "/vendor/**/*"], {
        read: false
      }).pipe(plugins.order([]));
    },
    src: function(src) {
      var filterInject;
      console.log('html injecting...');
      filterInject = filter("**/*.inject.html");
      return src.pipe(filterInject).pipe(plugins.inject(this.orderedVendorCss(), {
        name: 'bower',
        relative: true
      })).pipe(plugins.inject(this.orderedCustomCss(), {
        relative: true
      })).pipe(plugins.inject(this.orderedVendorJs(), {
        name: 'bower',
        relative: true
      })).pipe(plugins.inject(this.orderedCustomJs(), {
        relative: true
      })).pipe(plugins.rename(function(path) {
        return path.basename = path.basename.replace('.inject', '');
      })).pipe(filterInject.restore);
    }
  };

  Html = {
    compile: function() {
      console.log('compile html...');
      return this.src(gulp.src([DIST_PATH + "/**/*.jade", DIST_PATH + "/**/*.html"]));
    },
    src: function(src) {
      var filterJade;
      filterJade = filter("**/*.jade");
      src = src.pipe(filterJade).pipe(plugins.jade()).pipe(filterJade.restore).pipe(plugins.angularHtmlify());
      src = Inject.src(src);
      if (ENV_CURRENT === ENV.PROD) {
        src = src.pipe(plugins.htmlmin({
          collapseWhitespace: true,
          removeComments: true
        }));
      } else {
        src = src.pipe(plugins.prettify({
          indent_size: 2
        }));
      }
      return src.pipe(gulp.dest(PUBLIC_PATH));
    }
  };

  jadeWatch = function() {
    return gulp.src([DIST_PATH + "/**/*.jade", "!" + DIST_PATH + "/**/*.inject.jade"]).pipe(plugins.watch([DIST_PATH + "/**/*.jade", "!" + DIST_PATH + "/**/*.inject.jade"])).pipe(plugins.jade()).pipe(plugins.prettify({
      indent_size: 2
    })).pipe(gulp.dest(PUBLIC_PATH));
  };

  html = function() {
    var src;
    src = gulp.src(DIST_PATH + "/**/*.html").pipe(plugins.prettify({
      indent_size: 2
    })).pipe(plugins.angularHtmlify());
    src = Inject.src(src);
    return src.pipe(gulp.dest(PUBLIC_PATH));
  };

  images = function() {
    var ext;
    images = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = IMAGES.length; i < len; i++) {
        ext = IMAGES[i];
        results.push(DIST_PATH + "/**/*." + ext);
      }
      return results;
    })();
    return gulp.src(images).pipe(gulp.dest(PUBLIC_PATH));
  };

  sass = function() {
    return gulp.src([DIST_PATH + "/**/*.sass", DIST_PATH + "/**/*.scss"]).pipe(plugins.sass()).pipe(gulp.dest(PUBLIC_PATH));
  };

  css = function() {
    return gulp.src(DIST_PATH + "/**/*.css").pipe(plugins.autoprefixer()).pipe(gulp.dest(PUBLIC_PATH));
  };

  coffee = function() {
    return gulp.src(DIST_PATH + "/**/*.coffee").pipe(plugins.coffee()).pipe(gulp.dest(PUBLIC_PATH));
  };

  js = function() {
    return gulp.src(DIST_PATH + "/**/*.js").pipe(gulp.dest(PUBLIC_PATH));
  };

  watch = function() {};

  bower = function() {
    var cssFilter, jsFilter, q, src;
    q = Q.defer();
    cssFilter = filter('**/*.css');
    jsFilter = filter('**/*.js');
    src = gulp.src(plugins.mainBowerFiles({
      overrides: {
        bootstrap: {
          main: ["./dist/js/bootstrap.js", "./dist/css/bootstrap.css", "./dist/fonts/*"]
        }
      }
    }));
    if (ENV_CURRENT === ENV.PROD) {
      src = src.pipe(cssFilter).pipe(plugins.cssUrlAdjuster({
        replace: ['../fonts', './']
      })).pipe(plugins.order(ORDER_VENDOR_CSS)).pipe(plugins.concat('vendor.css')).pipe(plugins.csso()).pipe(cssFilter.restore);
    } else {
      src = src.pipe(cssFilter).pipe(plugins.cssUrlAdjuster({
        replace: ['../fonts', './']
      })).pipe(cssFilter.restore);
    }
    if (ENV_CURRENT === ENV.PROD) {
      src = src.pipe(jsFilter).pipe(plugins.order(ORDER_VENDOR_JS)).pipe(plugins.concat('vendor.js')).pipe(plugins.uglify({
        mangle: true
      })).pipe(jsFilter.restore);
    }
    src.pipe(gulp.dest(PUBLIC_PATH + "/vendor")).on('end', function() {
      return q.resolve();
    });
    return q.promise;
  };

  build = function() {
    return clean().then(function() {
      return Q.all([bower(), sass(), css(), coffee(), js(), images()]).then(function() {
        return Html.compile();
      });
    });
  };

  server = function() {
    return browserSync.init({
      server: {
        baseDir: PUBLIC_PATH
      },
      files: SERVER_WATCH ? PUBLIC_PATH + "/**/*" : false,
      port: PORT,
      open: OPEN_BROWSER,
      browser: "google chrome",
      reloadOnRestart: true
    });
  };

  tasks = {
    clean: {
      desc: "clean " + PUBLIC_PATH + " folder",
      action: clean
    },
    server: {
      desc: "start local server on port " + PORT,
      action: server
    },
    build: {
      desc: "build app: '--env [prod|dev]' default 'dev'",
      action: build
    },
    "default": {
      desc: "show tasks list",
      action: function() {
        var num, opts, prefix, results, task;
        console.log("----- available tasks -----");
        results = [];
        for (task in tasks) {
          opts = tasks[task];
          num = 10 - task.length;
          if (num < 0) {
            num = 0;
          }
          prefix = (function() {
            var results1;
            results1 = [];
            while (num -= 1) {
              results1.push(" ");
            }
            return results1;
          })();
          results.push(console.log("" + (prefix.join('')) + task + ": " + opts.desc));
        }
        return results;
      }
    }
  };

  for (task in tasks) {
    opts = tasks[task];
    gulp.task(task, opts.action);
  }

}).call(this);

//# sourceMappingURL=gulpfile.js.map
